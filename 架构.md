1. 分布式id的生成方式

   - uuid

   -  数据库自增ID

   - 数据库多主模式

   - 基于数据库的号段模式

     从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，加载到内存中使用

   - 基于redis模式

     利用redis的 incr命令实现ID的原子性自增

   - 基于雪花算法(snowflake)的模式

   - 百度(uid-generator)

     [一口气说出 9种 分布式ID生成方式](https://zhuanlan.zhihu.com/p/107420326)

2. 如何做系统优化

   [高并发大流量的处理方式](https://note.youdao.com/s/MIlFbEiJ)

3. epoll的多路复用机制
   有三种方式来实现多路复用
   select、poll、epoll
   前两种都是通过轮训的方式来实现，就是把所有的链接收集到服务端进行轮训，这种方式会产生空轮循，存在会有一部分的链接是不发送数据的
   最后一种是通过事件驱动的方式来实现
   首先会通过一个系统函数epoll_create来创建一个selector对象，也就是事件收集器，所有的事件都会注册进来，比如建立连接事件，数据IO事件，拿Redis来举例，当服务器启动时通过epoll_ctl注册accept事件，当有链接进来时注册IO事件，当没有事件或者响应注册时，通过epoll_await来阻塞等待。

   

4. 消息推送系统的瓶颈

   - 内核的瓶颈

     - 问题

       推送量大：假设有100万在线的链接 一秒钟发了10条消息，那么就需要推送1000万次

       linux内核发送TCP的极限包频也就 100万/秒

     - 优化

       将同一秒内的消息进行合并，合并成一条，合并后推送的次数就是在线链接数

   - 锁的瓶颈

     - 问题

       需要维护在线的用户集合（在线的长链接），通常是一个字典结构

       推送消息就是遍历整个集合，顺序发送消息，比较耗时

       推送期间，客户端仍然可以上下线，集合需要上锁

     - 优化

       大变小的方案

       将连接打散到多个集合中去，每个集合有自己的锁

       使用多线程并发的去推送多个集合，避免锁竞争

       读写锁替代互斥锁，多个推送任务可以并发的遍历同一个集合，提高并发度

   - Cpu瓶颈

     - 问题

       浏览器和服务端通过json格式进行通讯

       json编码比较耗费cpu资源

       向100万在线推送一次，则需要100万次json encode

     - 优化

       减少计算

       json编码的前置

5. php-连接池的实现

   - 连接池的定义

     连接池负责创建、管理、释放数据库连接（释放超时的数据库连接避免连接遗漏），它允许应用程序复用现有的数据库连接，而不是重新创建一个数据库连接，提高数据库的操作性能。

   - 好处

     减少开销-使数据库连接得到复用，避免频繁的创建、释放连接，减少了一定的性能开销。

     提高响应速度-连接池在初始化过程中，已经创建了一定的数据库连接，业务可以直接使用。

     统一管理，避免连接泄露-会检查释放超时的数据库连接。

   - 应用

     阿里云的RDS

     php + SQL Relay + mysql

     参考：[数据库连接池的实现](https://blog.csdn.net/u014559227/article/details/88343263)

     